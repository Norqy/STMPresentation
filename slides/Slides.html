
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="remark,remarkjs,markdown,slideshow,presentation" />
    <meta name="description" content="A simple, in-browser, markdown-driven slideshow tool." />
    <title>Scala Landscape</title>
    <style type="text/css">
      @import url(http://fonts.googleapis.com/css?family=Droid+Serif);
      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        -moz-border-radius: 5px;
        -web-border-radius: 5px;
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }

      .comment { display: None }

    </style>
  </head>
  <body>
    <textarea id="source">
name: inverse
layout: true
class: center, middle
---
#Software Transactional Memory for Scala
---
layout: false
class: left, middle

.left-column[
# Agenda
]
.right-column[
##A different approach to concurrency
- The problem
- Conventional solutions
- Transactional memory
- The Scala STM library
- Examples
]
---
layout: false
.left-column[
# The problem
]
.right-column[
##Share mutable state across multiple concurrent threads of execution

## This is dangerous
- Corruption
- Inconsistency
- Non-deterministic behavior (race conditions)
- Death

"the second you don't respect this, it will kill you"
<img src="GreenBallsOfDeath.jpg" style="width: 300px;" />
]
???
Stop and think about that.

Those words should make you feel uneasy. Look at all the danger words in there.
Words like _concurrency_, _mutable state_, _shared_ are all danger flags.

- Corruption from simultaneous write/read or simultaneous writes.
- Inconnsistency if two values must be modified as a unit but partial updates are visible.
- Race conditions happen when the outcome of a computation depends on order in which different threads execute.

Image and quote from _The Rock_, 1996, with Nicolas Cage and Sean Connery.

---
.left-column[
# The problem
]
.right-column[
##This problem is difficult...
- to reason about
- to debug
- to test
- to get correct in the first place
- to _keep_ correct over time

##How to solve a difficult problem?
##Avoid it!
- If possible, consider different solutions that don't share mutable state
- Maybe you really don't need to share the state
- Actors can help tame concurrency
- Sequence operations on shared data
]

---
.comment[
.left-column[
##A digression
###_and a small sermon_
]
.right-column[
##On the topic keeping concurrent code correct...

How concurrent code is _originally_ written can have a huge impact on how it is maintained.

- Make it very clear what values are shared between threads and what locks are used to protect them

- Minimize the size of your synchronized blocks as much possible -
  only protect what _needs_ protecting

- Document expected usage models
  - How many threads are expected
  - Are the threads from I/O, timer callbacks, event notifications
  - Anything that will help a maintainer understand your original intentions

]
???
---
]
.left-column[
##Conventional Solutions
]
.right-column[
- Identify _critical sections_ - blocks of code that manipulate shared state

- To enter a criticial section a thread must acquire exclusvie access to a
shared resource (e.g. monitor, mutex).

- A thread holds this exclusive access for the duration of the critical section
and other threads that attempt to acquire the resource block until it is released.

  - Reader/Writer locks can provide an optimization if most access is read only.
  - Allows unlimited simultaneous readers but closes the door when a write needs access.

- Concerns
  - Anything other than trivial Difficult
  - Deadlocks - Mixing mutual exclusion and blocking
  - Priority inversion - Mixing mutual exclusion, blocking and thread priorities
]
???
What's not on the list of concerns? Performance.

Acquiring a monitor has no significant impact on performance.

Don't ever not acquire a monitor because you thinks it's _slow_.
---
.left-column[
##A Different Approach
### Software Transactional Memory
]
.right-column[
##Software Transactional Memory
- _ACID_ transaction properties for memory operations
  - Atomic, Consistent, Isolated, ~~Durable~~
  - Critical sections execute in a _transaction_
  - Transactions can be commited, retried or rolled back
- _Optimistic_ execution strategy
  - Let threads execute critical sections concurrently
  - Detect illegal overlapping operations and retry

## STM in Scala
- Implemented as a library (.jar)
- Plain Scala code, no bytecode manipulation
- No external dependencies
- In the scala.concurrent.stm._ package
- Provides and API, SPI and a reference implementation
]
???
- Scala STM _may_ end up in the Standard library
---
.left-column[
##Scala STM
]
.right-column[
```scala
import scala.concurrent.stm._

private val count = Ref(0)  // count: Ref[Int]
private val data = Ref(Map.empty[Int, String])

def add(id: Int, name: String): Int =
  atomic { implicit txn =>
    data() = data() updated (id, name)
    count() = count() + 1
    count()
  }

def remove(id: Int): Int =
  atomic { implicit txn =>
    data() = data() - id
    count() = count() + 1
    count()
  }
```
- Transactional memory is wrapped inside `Ref`s
- `Ref`s can only be accessed inside `atomic` blocks
- `atomic` blocks supply a transaction to be used by the `Ref`s
- Access the contents of a `Ref` (read/write) with `()`
]
???
- Only `Ref`s are transactional
  - Not trying to make all memory transactional
  - `Ref` explicitly labels shared state
- Point out that `count` and `data` are `val`s, that is, immutable.
- The contents of `count` and `data` are also immutable
  - This is a 'best practice'
- `Ref`s _contain_ mutable data
  - a `Ref` is a place to keep mutable values
  - in this case _mutable_ values means that the contents of the `Ref` get
    replaced with new immutable values. It contains a _sequence_ of values over time.
  - together with transactions they provide safe concurrent access
- Hand wave about the syntax at this point. Details coming on a later slide.
- Leverage type system (say what you mean)
  - Shared state is explicity marked as `Ref`s
  - Accidentally using a `Ref` outside of an `atomic` block is a compile time error
  - This helps with maintenance by documenting exactly what is shared and where
---
.left-column[
##Scala STM
]
.right-column[
```scala
import scala.concurrent.stm._

private val count = Ref(0)  // count: Ref[Int]
private val data = Ref(Map.empty[Int, String])

def add(id: Int, name: String): Int =
  atomic { implicit txn =>
    data() = data() updated (id, name)
    count() = count() + 1
    count()
  }

def remove(id: Int): Int =
  atomic { implicit txn =>
    data() = data() - id
    count() = count() + 1
    count()
  }
```
- `atomic` is not `synchronized` - Any number of threads can be inside the `atomic` blocks at the same time
- The transaction
  - prevents corruption due to simultaneous writes
  - detects improper interleaving of threads
  - automatically restarts `atomic` block if necessary
  - automatically rolls back if an exception is thrown
]
???
- At this point just say that STM _can_ detect collisions and do the right thing
- There's a better way to do `count() = count() + 1` but this makes the read/write operations clearer right now
- Still hand waving about how this works
---
.left-column[
##Scala STM
]
.right-column[
```scala
import scala.concurrent.stm._

private val count = Ref(0)  // count: Ref[Int]
private val data = Ref(Map.empty[Int, String])

def add(id: Int, name: String): Int =
  atomic { implicit txn =>
    data() = data() updated (id, name)
    count() = count() + 1
    count()
  }

def remove(id: Int): Int =
  atomic { implicit txn =>
    data() = data() - id
    count() = count() + 1
    count()
  }
```
- { implict txn => ... } is a function literal
  - takes a single argument (an implicit transaction) and returns some value
- `atomic` is a function defined in `stm` package object
  - Takes a function from transaction => Z
  - Provides a transaction and invokes the given function
- What's with all those parens?
  - on the rhs `apply()` - reads the value from the `Ref`
  - on the lhs `update()` - writes a new value to the `Ref`
]
???
- Describe the functional syntax being used here.
  - { implict txn => ... } is a function literal taking a single argument (an implicit transaction)
  - `atomic` is a function, defined in `stm`, that takes a function from transaction => A
  - `atomic` creates a transaction and passes it to the provided function
- The parens are syntactic sugar for
  - `apply()` on the rhs
  - `update()` on the lhs
- Most Scala developers will be familiar with `apply` but `update` maybe new
  - Point out that the mutable `HashMap` usage uses `update`
  - .e.g m(1) = "One"
---
.left-column[
##Scala STM
]
.right-column[
```scala
import scala.concurrent.stm._

private val count = Ref.apply(0)  // count: Ref[Int]
private val data = Ref.apply(Map.empty[Int, String])

def add(id: Int, name: String): Int =
  stm.atomic({ implicit txn =>
    data.update(data.apply().updated(id, name))
    count.update(count.apply() + 1)
    count.apply()
  })

def remove(id: Int): Int =
  stm.atomic({ implicit txn =>
    data.update(data.apply() - id)
    count.update(count.apply() + 1)
    count.apply()
  })
```
The sugar-free version of the same code
]
???
- This just shows the fully de-sugared Scala code
- There's no reason to dwell on this slide
---
.left-column[
##Scala STM
]
.right-column[
How does it work?

- `apply` and `update` take a transaction as an implicit argument

- The transaction tracks `Ref`s that have been read so far
  - This is the transaction's _read set_
  - The results of the transaction depends only on the read set

- If another transaction writes to a `Ref` in the current read set
then the transaction has stale state and is rolled back and restarted from the beginning

- Transaction rollback can only happen during an `apply`, `update` or other transaction
method
]
???
- It isn't necessarily obvious but the result of the computation depend only
on the read set
---
.left-column[
##Scala STM
]
.right-column[
```scala
val data = Ref(Map(1 -> "One", 2 -> "Two", 3 -> "Three")
val count = Ref(4)
```
.pull-left[
<pre><code>
add(4, "Four")
atomic
| begin
| |  read data -> t1
| |  t2 &lt;- t1.updated(...)
| |  write data &lt;- t2
| |  read count -> t3
| |  t4 &lt;- t3 + 1
| |  write count &lt;- t4
| |  read count -> t5
| commit
+-> 5
</code></pre>
]
.pull-right[
<pre><code>
remove(1)
atomic
| begin
| |
| |  read data -> t1
| |  t2 &lt;- t1 - 1
| |  write data &lt;- t2
| rollback "read data stale"
| begin
| |  read data -> t1
| |  t2 &lt;- t1 - 1
| |  write data &lt;- t2
| |  read count -> t3
| |  t4 &lt;- t3 + 1
| |  write count &lt;- t4
| |  read count -> t5
| commit
+-> 6
</code></pre>
]
]
???
- This is only a schematic of what's really going on under the covers
- There's no magic, just accurate and efficient bookeeping
- Don't get too bogged down in the details
---
.left-column[
##Scala STM
]
.right-column[
```scala
import scala.concurrent.stm._

private val count = Ref(0)  // count: Ref[Int]
private val data = Ref(Map.empty[Int, String])

def add(id: Int, name: String): Int =
  atomic { implicit txn =>
    data() = data() updated (id, name)
    count() = count() + 1
    count()
  }

def remove(id: Int): Int =
  atomic { implicit txn =>
    data() = data() - id
    count() = count() + 1
    count()
  }
```
- Recall the code from a few slides ago
- Consider the following statements
  - `data() = data() updated (id, name)`
  - `count() = count() + 1`
- Both of these change the data inside a `Ref` by first
extracting the value, computing a new value and finally storing
the new value back into the `Ref`
- That sounds familiar
]
???
- This code works just fine but it's kind of ugly and can be written
in a slightly more efficient way
- I started with this implementation because it makes the reads and writes explicit
---
.left-column[
##Scala STM
]
.right-column[
```scala
  private val count = Ref(0)  // count: Ref[Int]
  private val data = Ref(Map.empty[Int, String])

  def add(id: Int, name: String): Int =
    atomic { implicit txn =>
      data transform (_ updated (id, name))
      count transformAndGet (_ + 1)
    }

  def remove(id: Int): Int =
    atomic { implicit txn =>
      data transform (_ - id)
      count transformAndGet (_ + 1)
    }
```
- A cleaner implementation
  - `Ref.transform` performs an atomic transformation of the `Ref`s value
  - `Ref.transformAndGet` also returns the `Ref`'s new value
  - `Ref` also provides `getAndTransform`, `swap`, `get`, `*=`, `+=`, `/=`, ...
]
???
- `transform` instead of `map`?
  - Probably to stress that it changes the `Ref`
  - `map` leaves the existing data unchanged and returns a new instance
- This code accomplishes the same thing as before but is a little cleaner
---
.left-column[
##Scala STM
]
.right-column[
```scala
  private val count = Ref(0)  // count: Ref[Int]
  private val data = Ref(Map.empty[Int, String])

  def add(id: Int, name: String): Int =
    atomic { implicit txn =>
      data transform (_ updated (id, name))
      count transformAndGet (_ + 1)
    }

  def remove(id: Int): Int =
    atomic { implicit txn =>
      data transform (_ - id)
      count transformAndGet (_ + 1)
    }

  private val countView = count.single
  def currentCount = countView()

  private val dataView = data.single
  def currentData = dataView()
```
- `Ref.single` creates a `View`
  - A convience for single statement operations
  - Can be used outside of a transaction
  - atomic { implicit t => count() } ==> count.single()
  - atomic { implicit t => count() = 5 } ==> count.single() = 5
]
???
- `View` has most of the atomic operations as `Ref`
  - `transform`, `transformAndGet`, ...
---
.left-column[
##Scala STM
]
.right-column[
##Things to keep in mind
- Some code paths to execute multiple times
  - Avoid I/O in `atomic` blocks
  - Keep `atomic` blocks as small as possible
  - Handlers can be installed on the transaction to deal with non-repeatable code
- Ordering of `atomic` operations is non-deterministic
  - Atomicity insures that result of concurrent atomic operations is the same as if the
    operations ran sequentially
  - The results of a sequence of operations may differ depending on their order
  - STM guarantees that the final result is one of the valid results but not which one
- Performance
  - STM is cheap but not free
  - Benchmark or profile for your use cases
]
???
- Use the banking example from SICP to discuss non-determinism
  - Bank account starts with $100
  - Peter deposits $40
  - Paul withdraw half of the current balance
  - Depending on order the account balance may be $90 or $70
  - Either is valid and the system in consistent because the total money is consserved
---
.left-column[
##Scala STM
]
.right-column[
```scala
  private val count = Ref(0)  // count: Ref[Int]
  private val data = Ref(Map.empty[Int, String])

  def add(id: Int, name: String): Int = ...

  def remove(id: Int): Int = ...

  def getOrWait(x: Int): String = {
    atomic { implicit txn =>
      data() get x getOrElse retry
    }
  }

  def getOrWait(x: Int, timeout: Long): Option[String] = {
    atomic { implicit txn =>
      data() get x match {
        case Some(s) => Some(s)
        case None => retryFor(timeout); None
      }
    }
  }
```
- `retry` causes `atomic` to rewinde and block
  - Use `retry` to indicate that you can't proceed with the current state
  - `atomic` will block and automatically restart when anything in the current read set changes
  - Use `retryFor` to supply a timeout
]
???
- The timeout in `retryFor` is cumlative.
---
.left-column[
##Scala STM
]
.right-column[
```scala
class Fork { val inUse = Ref(false) }

def meal(left: Fork, right: Fork) {
  // thinking
  atomic { implicit txn =>
    if (left.inUse() || right.inUse())
      retry // forks are not both ready, wait
    left.inUse() = true
    right.inUse() = true
  }
  // eating
  atomic { implicit txn =>
    left.inUse() = false
    right.inUse() = false
  }
}
```
- Dining Philolsphers problem
  - Forks are shared between two philosphers
  - A philosopher needs to pick up both forks in order to eat
  - If either fork is in use then block until the state changes
]
???
- This example comes from the Scala STM documentation
- Note that what values are waited on depends on how far we get before detecting an in-use fork
---
    </textarea>
    <script src="http://gnab.github.com/remark/downloads/remark-0.6.5.min.js" type="text/javascript"></script>
    <script type="text/javascript">
      var hljs = remark.highlighter.engine;
    </script>
    <script src="remark.language.js" type="text/javascript"></script>
    <script type="text/javascript">
      var slideshow = remark.create({
          highlightStyle: 'monokai',
          highlightLanguage: 'remark'
        }) ;
    </script>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-44561333-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </body>
</html>
